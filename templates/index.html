<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced PDF Text Overlay Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f7fa;
            color: #333;
            overflow-x: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 5px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1rem;
        }

        .main-container {
            display: flex;
            height: calc(100vh - 100px);
            gap: 20px;
            padding: 20px;
        }

        /* PDF Preview Section */
        .pdf-section {
            flex: 1;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .pdf-header {
            background: linear-gradient(90deg, #667eea, #764ba2);
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .pdf-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .page-nav {
            background: rgba(255,255,255,0.2);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .page-nav:hover {
            background: rgba(255,255,255,0.3);
        }

        .page-nav:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .upload-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 3px dashed #667eea;
            margin: 20px;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(45deg, rgba(102, 126, 234, 0.05) 0%, rgba(118, 75, 162, 0.05) 100%);
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: linear-gradient(45deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
        }

        .upload-content {
            text-align: center;
            padding: 40px;
        }

        .upload-icon {
            font-size: 4rem;
            color: #667eea;
            margin-bottom: 20px;
        }

        .pdf-viewer {
            flex: 1;
            position: relative;
            overflow: auto;
            background: #f8f9fa;
            display: none;
        }

        .pdf-canvas {
            display: block;
            margin: 20px auto;
            border: 1px solid #ddd;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            cursor: crosshair;
        }

        .text-overlay {
            position: absolute;
            background: rgba(102, 126, 234, 0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
            pointer-events: none;
            transform: translate(-50%, -100%);
            white-space: nowrap;
            z-index: 1000;
        }

        .image-overlay {
            position: absolute;
            background: rgba(76, 175, 80, 0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
            pointer-events: none;
            transform: translate(-50%, -100%);
            white-space: nowrap;
            z-index: 1000;
        }

        .shape-overlay {
            position: absolute;
            background: rgba(255, 152, 0, 0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 12px;
            pointer-events: none;
            transform: translate(-50%, -100%);
            white-space: nowrap;
            z-index: 1000;
        }

        .coordinate-dot {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 999;
            pointer-events: none;
        }

        .coordinate-dot.simple {
            background-color: #667eea;
        }

        .coordinate-dot.conditional {
            background-color: #ff9800;
        }

        .coordinate-dot.image {
            background-color: #4caf50;
        }

        .coordinate-dot.shape {
            background-color: #ff9800;
        }

        /* Configuration Section */
        .config-section {
            flex: 1;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .config-header {
            background: linear-gradient(90deg, #764ba2, #667eea);
            color: white;
            padding: 15px 20px;
        }

        .config-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .section {
            margin-bottom: 25px;
            padding: 20px;
            border: 1px solid #e1e5e9;
            border-radius: 10px;
            background: #f8f9fa;
        }

        .section h3 {
            margin-bottom: 15px;
            color: #667eea;
            font-size: 1.2rem;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
        }

        .form-control {
            width: 100%;
            padding: 10px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 0.9rem;
            transition: border-color 0.3s ease;
        }

        .form-control:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        textarea.form-control {
            resize: vertical;
            min-height: 120px;
            font-family: 'Courier New', monospace;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }

        .btn-danger {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }

        .btn-warning {
            background: linear-gradient(135deg, #ffc107 0%, #ff8c00 100%);
        }

        .btn-info {
            background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);
        }

        .btn-block {
            width: 100%;
            margin-bottom: 10px;
        }

        .variable-item, .image-item, .shape-item {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            position: relative;
        }

        .image-item {
            border-left: 4px solid #4caf50;
        }

        .shape-item {
            border-left: 4px solid #ff9800;
        }

        .variable-header, .image-header, .shape-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .remove-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        .coordinate-display {
            background: #e9ecef;
            padding: 8px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }

        .config-output {
            background: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            min-height: 400px;
            max-height: 600px;
            overflow-y: auto;
            white-space: pre-wrap;
            border: 2px solid #4a5568;
            line-height: 1.4;
            width: 100%;
        }

        .click-instruction {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            text-align: center;
            font-size: 0.9rem;
        }

        .current-page-indicator {
            background: rgba(255,255,255,0.2);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9rem;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            z-index: 1000;
            max-width: 300px;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s ease;
        }

        .notification.show {
            opacity: 1;
            transform: translateY(0);
        }

        .notification.success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }

        .notification.error {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #667eea;
        }

        .loading.show {
            display: block;
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            background: #e9ecef;
            padding: 5px;
            border-radius: 8px;
        }

        .mode-btn {
            flex: 1;
            padding: 8px 12px;
            border: none;
            background: transparent;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: #667eea;
            color: white;
        }

        .image-upload-area {
            border: 2px dashed #4caf50;
            padding: 20px;
            text-align: center;
            border-radius: 8px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .image-upload-area:hover {
            background: rgba(76, 175, 80, 0.1);
        }

        .image-list {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 10px;
        }

        .image-item-small {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }

        .shape-preview {
            width: 30px;
            height: 30px;
            border: 2px solid #ff9800;
            display: inline-block;
            margin-right: 10px;
            vertical-align: middle;
        }

        .shape-preview.rectangle {
            border-radius: 0;
        }

        .shape-preview.circle {
            border-radius: 50%;
        }

        .shape-preview.line {
            border: none;
            border-top: 2px solid #ff9800;
            height: 0;
            margin-top: 15px;
        }

        .coordinate-debug {
            background: #ffeaa7;
            padding: 8px;
            border-radius: 5px;
            margin-top: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            border: 1px solid #fdcb6e;
        }

        @media (max-width: 1200px) {
            .main-container {
                flex-direction: column;
                height: auto;
            }
            
            .pdf-section, .config-section {
                flex: none;
                min-height: 500px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🚀 Enhanced PDF Overlay Tool (Fixed Coordinates)</h1>
        <p>Upload, configure, and process PDF with accurate coordinate mapping</p>
    </div>

    <div class="main-container">
        <!-- PDF Preview Section -->
        <div class="pdf-section">
            <div class="pdf-header">
                <h3>📖 PDF Preview</h3>
                <div class="pdf-controls" id="pdfControls" style="display: none;">
                    <button class="page-nav" id="prevPage">← Previous</button>
                    <span class="current-page-indicator" id="pageInfo">Page 1 of 1</span>
                    <button class="page-nav" id="nextPage">Next →</button>
                </div>
            </div>
            
            <div class="upload-area" id="uploadArea">
                <div class="upload-content">
                    <div class="upload-icon">📁</div>
                    <h3>Upload Your PDF</h3>
                    <p>Drag and drop a PDF file here or click to browse</p>
                    <input type="file" id="pdfInput" accept=".pdf" style="display: none;">
                </div>
            </div>

            <div class="pdf-viewer" id="pdfViewer">
                <div class="click-instruction">
                    🎯 <strong>Current Mode: <span id="currentMode">Text</span></strong>
                    <br><small id="modeInstructions">💡 Click to add text variables | 🖼️ Click to place images | 🔲 Click to draw shapes</small>
                    <br><small>Blue = Text | Green = Images | Orange = Shapes</small>
                    <br><small>Hold <strong>Ctrl/Cmd</strong> + Click to add conditional coordinates to text variables</small>
                    <div id="lineDrawingControls" style="display: none; margin-top: 10px;">
                        <button class="btn btn-secondary" id="cancelLineBtn" style="padding: 5px 10px; font-size: 0.8rem;">❌ Cancel Line Drawing</button>
                    </div>
                </div>
                <canvas id="pdfCanvas" class="pdf-canvas"></canvas>
            </div>

            <div class="loading" id="uploadLoading">
                <div>📤 Uploading PDF...</div>
            </div>
        </div>

        <!-- Configuration Section -->
        <div class="config-section">
            <div class="config-header">
                <h3>⚙️ Configuration & Processing</h3>
            </div>
            
            <div class="config-content">
                <!-- Mode Selector -->
                <div class="section">
                    <h3>🎯 Editing Mode</h3>
                    <div class="mode-selector">
                        <button class="mode-btn active" id="textMode" onclick="setMode('text')">📝 Text</button>
                        <button class="mode-btn" id="imageMode" onclick="setMode('image')">🖼️ Images</button>
                        <button class="mode-btn" id="shapeMode" onclick="setMode('shape')">🔲 Shapes</button>
                    </div>
                    <div id="modeInstructions" class="click-instruction">
                        <strong>Text Mode:</strong> Click on the PDF to add text variables at specific positions.
                    </div>
                </div>

                <!-- Image Upload Section -->
                <div class="section" id="imageUploadSection" style="display: none;">
                    <h3>🖼️ Image Upload</h3>
                    <div class="image-upload-area" id="imageUploadArea">
                        <div>📷 Click to upload images (PNG, JPG, GIF)</div>
                        <input type="file" id="imageInput" accept=".png,.jpg,.jpeg,.gif,.bmp" multiple style="display: none;">
                    </div>
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <button class="btn btn-info" onclick="refreshImageList()" style="flex: 1;">🔄 Refresh Images</button>
                    </div>
                    <div id="imageList" class="image-list">
                        <div>No images uploaded yet</div>
                    </div>
                </div>

                <!-- Sample Data Section -->
                <div class="section">
                    <h3>📝 Sample Data</h3>
                    <div class="form-group">
                        <label>Sample JSON Data (for overlay processing):</label>
                        <textarea class="form-control" id="sampleData" placeholder='Enter sample data in JSON format, e.g.:
{
  "name": "John Doe",
  "email": "john@example.com",
  "date": "2024-01-15"
}'></textarea>
                    </div>
                    <button class="btn btn-success btn-block" id="prefillBtn">✨ Prefill Data Based on Config</button>
                </div>

                <!-- Variables Section -->
                <div class="section">
                    <h3>🎯 Text Variables</h3>
                    <div id="variablesList">
                        <!-- Variables will be added here dynamically -->
                    </div>
                    <button class="btn btn-secondary btn-block" id="addVariableBtn">+ Add Variable</button>
                </div>

                <!-- Images Section -->
                <div class="section">
                    <h3>🖼️ Image Overlays</h3>
                    <div id="imagesList">
                        <!-- Images will be added here dynamically -->
                    </div>
                </div>

                <!-- Shapes Section -->
                <div class="section">
                    <h3>🔲 Shape Overlays</h3>
                    <div id="shapesList">
                        <!-- Shapes will be added here dynamically -->
                    </div>
                </div>

                <!-- Processing Section -->
                <div class="section">
                    <h3>🔧 Process PDF</h3>
                    <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin-bottom: 10px; font-size: 0.85rem;">
                        🎯 <strong>Tips:</strong> Click the center of elements for precise positioning. Different modes place different overlay types.
                        <br>• Blue dots = Text positions | Green dots = Image positions | Orange dots = Shape positions
                    </div>
                    <button class="btn btn-block" id="processBtn" disabled>🚀 Process PDF with All Overlays</button>
                    <div class="loading" id="processLoading">
                        <div>⚙️ Processing PDF...</div>
                    </div>
                    <div id="downloadSection" style="display: none; margin-top: 15px;">
                        <button class="btn btn-success btn-block" id="downloadBtn">💾 Download Processed PDF</button>
                    </div>
                </div>

                <!-- Configuration Output -->
                <div class="section">
                    <h3>📋 Generated Configuration</h3>
                    <div style="background: #e3f2fd; padding: 10px; border-radius: 5px; margin-bottom: 10px; font-size: 0.85rem;">
                        💡 <strong>Note:</strong> Page numbers in config are 0-based (Page 1 → 0, Page 2 → 1, etc.)
                        <br>📝 Shapes are converted to draw_shape variables with coordinates in inches (72 DPI conversion)
                        <br>🎨 Colors are converted to RGB values (0.0-1.0) in the draw_shape format
                    </div>
                    <div class="form-group">
                        <label>Configuration JSON (Editable):</label>
                        <textarea class="config-output" id="configOutput" contenteditable="true">Click on the PDF to start adding elements...</textarea>
                    </div>
                    <div style="display: flex; gap: 10px; margin-top: 15px; flex-wrap: wrap;">
                        <button class="btn" id="copyConfigBtn" style="flex: 1; min-width: 120px;">📋 Copy Config</button>
                        <button class="btn btn-secondary" id="saveConfigBtn" style="flex: 1; min-width: 120px;">💾 Save Config</button>
                        <button class="btn btn-success" id="loadFromConfigBtn" style="flex: 1; min-width: 140px;">📥 Load from Config</button>
                        <button class="btn btn-info" id="testImagesBtn" style="flex: 1; min-width: 120px;">🔍 Test Images</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Notification area -->
    <div id="notification" class="notification"></div>

    <script>
        // Global variables
        let pdfDoc = null;
        let currentPage = 1;
        let totalPages = 0;
        let pdfCanvas = null;
        let pdfCtx = null;
        let variables = [];
        let images = [];
        let shapes = [];
        let scale = 1.5;
        let pdfUploaded = false;
        let processedFilename = null;
        let pdfPageDimensions = {};
        let currentMode = 'text';
        let uploadedImages = [];
        let lineDrawingState = null;
        let tempLineStart = null;

        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // DOM elements
        const uploadArea = document.getElementById('uploadArea');
        const pdfInput = document.getElementById('pdfInput');
        const pdfViewer = document.getElementById('pdfViewer');
        const pdfControls = document.getElementById('pdfControls');
        pdfCanvas = document.getElementById('pdfCanvas');
        pdfCtx = pdfCanvas.getContext('2d');
        const pageInfo = document.getElementById('pageInfo');
        const prevPageBtn = document.getElementById('prevPage');
        const nextPageBtn = document.getElementById('nextPage');
        const variablesList = document.getElementById('variablesList');
        const imagesList = document.getElementById('imagesList');
        const shapesList = document.getElementById('shapesList');
        const addVariableBtn = document.getElementById('addVariableBtn');
        const configOutput = document.getElementById('configOutput');
        const copyConfigBtn = document.getElementById('copyConfigBtn');
        const saveConfigBtn = document.getElementById('saveConfigBtn');
        const loadFromConfigBtn = document.getElementById('loadFromConfigBtn');
        const sampleData = document.getElementById('sampleData');
        const prefillBtn = document.getElementById('prefillBtn');
        const processBtn = document.getElementById('processBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const uploadLoading = document.getElementById('uploadLoading');
        const processLoading = document.getElementById('processLoading');
        const downloadSection = document.getElementById('downloadSection');
        const notification = document.getElementById('notification');
        const imageUploadArea = document.getElementById('imageUploadArea');
        const imageInput = document.getElementById('imageInput');
        const imageList = document.getElementById('imageList');
        const imageUploadSection = document.getElementById('imageUploadSection');
        const currentModeSpan = document.getElementById('currentMode');
        const modeInstructions = document.getElementById('modeInstructions');
        const cancelLineBtn = document.getElementById('cancelLineBtn');
        const lineDrawingControls = document.getElementById('lineDrawingControls');
        const testImagesBtn = document.getElementById('testImagesBtn');

        // Event listeners
        uploadArea.addEventListener('click', () => pdfInput.click());
        uploadArea.addEventListener('dragover', handleDragOver);
        uploadArea.addEventListener('drop', handleDrop);
        pdfInput.addEventListener('change', handleFileSelect);
        pdfCanvas.addEventListener('click', handleCanvasClick);
        prevPageBtn.addEventListener('click', () => changePage(-1));
        nextPageBtn.addEventListener('click', () => changePage(1));
        addVariableBtn.addEventListener('click', addVariable);
        copyConfigBtn.addEventListener('click', copyConfiguration);
        saveConfigBtn.addEventListener('click', saveConfiguration);
        loadFromConfigBtn.addEventListener('click', loadFromConfiguration);
        prefillBtn.addEventListener('click', prefillSampleData);
        processBtn.addEventListener('click', processDocument);
        downloadBtn.addEventListener('click', downloadProcessedPDF);
        imageUploadArea.addEventListener('click', () => imageInput.click());
        imageInput.addEventListener('change', handleImageUpload);
        cancelLineBtn.addEventListener('click', cancelLineDrawing);
        testImagesBtn.addEventListener('click', testImageAccessibility);

        // Fixed coordinate conversion functions
        function canvasToPDFCoordinates(canvasX, canvasY, pageNum) {
            const pdfPageDim = pdfPageDimensions[pageNum] || { width: 612, height: 792 };
            
            // Calculate scale factors
            const scaleX = pdfPageDim.width / pdfCanvas.width;
            const scaleY = pdfPageDim.height / pdfCanvas.height;
            
            // Convert canvas coordinates to PDF coordinates
            const pdfX = Math.round(canvasX * scaleX);
            const pdfY = Math.round(pdfPageDim.height - (canvasY * scaleY)); // PDF Y increases upward
            
            return { x: pdfX, y: pdfY };
        }

        function pdfToCanvasCoordinates(pdfX, pdfY, pageNum) {
            const pdfPageDim = pdfPageDimensions[pageNum] || { width: 612, height: 792 };
            
            // Calculate scale factors
            const scaleX = pdfCanvas.width / pdfPageDim.width;
            const scaleY = pdfCanvas.height / pdfPageDim.height;
            
            // Convert PDF coordinates to canvas coordinates
            const canvasX = Math.round(pdfX * scaleX);
            const canvasY = Math.round((pdfPageDim.height - pdfY) * scaleY); // PDF Y increases upward
            
            return { x: canvasX, y: canvasY };
        }

        // Mode management
        function setMode(mode) {
            if (currentMode === 'shape' && lineDrawingState) {
                lineDrawingState = null;
                tempLineStart = null;
                removeTemporaryLinePoints();
            }
            
            currentMode = mode;
            
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(mode + 'Mode').classList.add('active');
            
            currentModeSpan.textContent = mode.charAt(0).toUpperCase() + mode.slice(1);
            
            updateModeInstructions();
            
            imageUploadSection.style.display = mode === 'image' ? 'block' : 'none';
            
            pdfCanvas.style.cursor = mode === 'text' ? 'crosshair' : 
                                   mode === 'image' ? 'copy' : 'crosshair';
        }

        function updateModeInstructions() {
            let instructions;
            
            if (currentMode === 'text') {
                instructions = '<strong>Text Mode:</strong> Click on the PDF to add text variables at specific positions.';
            } else if (currentMode === 'image') {
                instructions = '<strong>Image Mode:</strong> First upload images, then click on the PDF to place them at specific positions.';
            } else if (currentMode === 'shape') {
                if (lineDrawingState === 'waiting_for_start') {
                    instructions = '<strong>Shape Mode - Line Drawing:</strong> <span style="color: #ff4444;">●</span> Click to set the START point of the line.';
                } else if (lineDrawingState === 'waiting_for_end') {
                    instructions = '<strong>Shape Mode - Line Drawing:</strong> <span style="color: #44ff44;">●</span> Click to set the END point of the line.';
                } else {
                    instructions = '<strong>Shape Mode:</strong> Click on the PDF to add shapes (rectangles, circles, lines) at specific positions.';
                }
            }
            
            modeInstructions.innerHTML = instructions;
            
            if (lineDrawingState) {
                lineDrawingControls.style.display = 'block';
            } else {
                lineDrawingControls.style.display = 'none';
            }
        }

        function cancelLineDrawing() {
            lineDrawingState = null;
            tempLineStart = null;
            removeTemporaryLinePoints();
            updateModeInstructions();
            showNotification('Line drawing cancelled.', 'success');
        }

        // Utility functions
        function showNotification(message, type = 'success') {
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.classList.add('show');
            setTimeout(() => {
                notification.classList.remove('show');
            }, 4000);
        }

        function showLoading(element) {
            element.classList.add('show');
        }

        function hideLoading(element) {
            element.classList.remove('show');
        }

        // File handling
        function handleDragOver(e) {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                uploadPDF(files[0]);
            }
        }

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                uploadPDF(file);
            }
        }

        // Image handling functions (keeping existing functionality)
        async function handleImageUpload(e) {
            const files = Array.from(e.target.files);
            
            for (const file of files) {
                if (file.size > 10 * 1024 * 1024) {
                    showNotification(`Image ${file.name} too large. Maximum size is 10MB.`, 'error');
                    continue;
                }
                
                const formData = new FormData();
                formData.append('image', file);
                
                try {
                    const response = await fetch('/api/upload-image', {
                        method: 'POST',
                        body: formData
                    });
                    
                    const result = await response.json();
                    
                    if (result.success) {
                        showNotification(`Image ${result.filename} uploaded successfully!`);
                        await loadUploadedImages();
                    } else {
                        showNotification(result.error, 'error');
                    }
                } catch (error) {
                    showNotification('Image upload failed: ' + error.message, 'error');
                }
            }
        }

        async function refreshImageList() {
            try {
                const response = await fetch('/api/images');
                const result = await response.json();
                
                if (result.success) {
                    uploadedImages = result.images;
                    updateImageList();
                    
                    const currentData = sampleData.value.trim();
                    if (!currentData || currentData === '{}') {
                        initializeSampleData();
                    }
                } else {
                    console.error('Failed to load images:', result.error);
                }
            } catch (error) {
                console.error('Error refreshing image list:', error);
            }
        }

        async function loadUploadedImages() {
            await refreshImageList();
        }

        function updateImageList() {
            if (uploadedImages.length === 0) {
                imageList.innerHTML = '<div>No images uploaded yet</div>';
                return;
            }
            
            imageList.innerHTML = uploadedImages.map(img => 
                `<div class="image-item-small">
                    <span>📷 ${img.filename}</span>
                    <div style="display: flex; flex-direction: column; align-items: flex-end;">
                        <small>${new Date(img.upload_time).toLocaleDateString()}</small>
                        <small style="color: #007bff; font-size: 0.7rem;">URL: ${window.location.origin}${img.url}</small>
                    </div>
                </div>`
            ).join('');
        }

        // PDF upload and processing
        async function uploadPDF(file) {
            if (file.size > 16 * 1024 * 1024) {
                showNotification('File too large. Maximum size is 16MB.', 'error');
                return;
            }

            showLoading(uploadLoading);
            
            const formData = new FormData();
            formData.append('pdf', file);

            try {
                const response = await fetch('/api/upload', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();
                
                if (result.success) {
                    showNotification(result.message);
                    await loadPDFForPreview(file);
                    await loadUploadedImages();
                    pdfUploaded = true;
                    processBtn.disabled = false;
                } else {
                    showNotification(result.error, 'error');
                }
            } catch (error) {
                showNotification('Upload failed: ' + error.message, 'error');
            } finally {
                hideLoading(uploadLoading);
            }
        }

        async function loadPDFForPreview(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                pdfDoc = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                totalPages = pdfDoc.numPages;
                currentPage = 1;
                
                await getPDFDimensions();
                
                uploadArea.style.display = 'none';
                pdfViewer.style.display = 'block';
                pdfControls.style.display = 'flex';
                
                await renderPage(currentPage);
                updatePageInfo();
                variables = [];
                images = [];
                shapes = [];
                updateAllLists();
                updateConfiguration();
            } catch (error) {
                showNotification('Error loading PDF preview: ' + error.message, 'error');
            }
        }

        async function getPDFDimensions() {
            try {
                const response = await fetch('/api/pdf-info');
                const result = await response.json();
                
                if (result.success) {
                    result.pages.forEach(page => {
                        pdfPageDimensions[page.page] = {
                            width: page.width,
                            height: page.height
                        };
                    });
                } else {
                    console.warn('Could not get PDF dimensions:', result.error);
                    for (let i = 1; i <= totalPages; i++) {
                        pdfPageDimensions[i] = { width: 612, height: 792 };
                    }
                }
            } catch (error) {
                console.warn('Error getting PDF dimensions:', error);
                for (let i = 1; i <= totalPages; i++) {
                    pdfPageDimensions[i] = { width: 612, height: 792 };
                }
            }
        }

        async function renderPage(pageNum) {
            try {
                const page = await pdfDoc.getPage(pageNum);
                const viewport = page.getViewport({scale: scale});
                
                pdfCanvas.width = viewport.width;
                pdfCanvas.height = viewport.height;

                const renderContext = {
                    canvasContext: pdfCtx,
                    viewport: viewport
                };
                
                await page.render(renderContext).promise;
                renderAllOverlays();
            } catch (error) {
                console.error('Error rendering page:', error);
            }
        }

        function renderAllOverlays() {
            const existingOverlays = pdfViewer.querySelectorAll('.text-overlay, .image-overlay, .shape-overlay, .coordinate-dot');
            existingOverlays.forEach(element => element.remove());

            const canvasRect = pdfCanvas.getBoundingClientRect();
            const viewerRect = pdfViewer.getBoundingClientRect();
            const offsetX = canvasRect.left - viewerRect.left;
            const offsetY = canvasRect.top - viewerRect.top;

            // Render text variables
            const currentPageVars = variables.filter(v => v.page === currentPage);
            currentPageVars.forEach(variable => {
                if (variable.type === 'simple') {
                    const canvasCoords = pdfToCanvasCoordinates(variable.x, variable.y, currentPage);

                    const overlay = document.createElement('div');
                    overlay.className = 'text-overlay';
                    overlay.textContent = `${variable.name} (${variable.x}, ${variable.y})`;
                    overlay.style.left = (canvasCoords.x + offsetX) + 'px';
                    overlay.style.top = (canvasCoords.y + offsetY - 10) + 'px';
                    pdfViewer.appendChild(overlay);

                    const dot = document.createElement('div');
                    dot.className = 'coordinate-dot simple';
                    dot.style.left = (canvasCoords.x + offsetX) + 'px';
                    dot.style.top = (canvasCoords.y + offsetY) + 'px';
                    pdfViewer.appendChild(dot);

                } else if (variable.type === 'conditional') {
                    variable.conditionalCoordinates.forEach((cond, index) => {
                        const canvasCoords = pdfToCanvasCoordinates(cond.x, cond.y, currentPage);

                        const overlay = document.createElement('div');
                        overlay.className = 'text-overlay';
                        overlay.style.background = 'rgba(255, 152, 0, 0.8)';
                        overlay.textContent = `${variable.name}[${cond.if_value || '?'}] (${cond.x}, ${cond.y})`;
                        overlay.style.left = (canvasCoords.x + offsetX) + 'px';
                        overlay.style.top = (canvasCoords.y + offsetY - 10) + 'px';
                        pdfViewer.appendChild(overlay);

                        const dot = document.createElement('div');
                        dot.className = 'coordinate-dot conditional';
                        dot.style.left = (canvasCoords.x + offsetX) + 'px';
                        dot.style.top = (canvasCoords.y + offsetY) + 'px';
                        pdfViewer.appendChild(dot);
                    });
                }
            });

            // Render images
            const currentPageImages = images.filter(img => img.page === currentPage);
            currentPageImages.forEach(image => {
                const canvasCoords = pdfToCanvasCoordinates(image.x, image.y, currentPage);

                const overlay = document.createElement('div');
                overlay.className = 'image-overlay';
                overlay.textContent = `🖼️ ${image.name} (${image.width}x${image.height})`;
                overlay.style.left = (canvasCoords.x + offsetX) + 'px';
                overlay.style.top = (canvasCoords.y + offsetY - 10) + 'px';
                pdfViewer.appendChild(overlay);

                const dot = document.createElement('div');
                dot.className = 'coordinate-dot image';
                dot.style.left = (canvasCoords.x + offsetX) + 'px';
                dot.style.top = (canvasCoords.y + offsetY) + 'px';
                pdfViewer.appendChild(dot);
            });

            // Render shapes
            const currentPageShapes = shapes.filter(shape => shape.page === currentPage);
            currentPageShapes.forEach(shape => {
                const canvasCoords = pdfToCanvasCoordinates(shape.x, shape.y, currentPage);

                const overlay = document.createElement('div');
                overlay.className = 'shape-overlay';
                overlay.textContent = `${shape.type} (${shape.width || 'N/A'}x${shape.height || 'N/A'})`;
                overlay.style.left = (canvasCoords.x + offsetX) + 'px';
                overlay.style.top = (canvasCoords.y + offsetY - 10) + 'px';
                pdfViewer.appendChild(overlay);

                const dot = document.createElement('div');
                dot.className = 'coordinate-dot shape';
                dot.style.left = (canvasCoords.x + offsetX) + 'px';
                dot.style.top = (canvasCoords.y + offsetY) + 'px';
                pdfViewer.appendChild(dot);
            });
        }

        function changePage(direction) {
            const newPage = currentPage + direction;
            if (newPage >= 1 && newPage <= totalPages) {
                currentPage = newPage;
                renderPage(currentPage);
                updatePageInfo();
                
                if (lineDrawingState) {
                    cancelLineDrawing();
                }
            }
        }

        function updatePageInfo() {
            pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
            prevPageBtn.disabled = currentPage <= 1;
            nextPageBtn.disabled = currentPage >= totalPages;
        }

        function handleCanvasClick(e) {
            const rect = pdfCanvas.getBoundingClientRect();
            const canvasX = Math.round(e.clientX - rect.left);
            const canvasY = Math.round(e.clientY - rect.top);
            
            if (currentMode === 'text') {
                if (e.ctrlKey || e.metaKey) {
                    const pdfCoords = canvasToPDFCoordinates(canvasX, canvasY, currentPage);
                    addConditionalCoordinateByClick(pdfCoords.x, pdfCoords.y);
                } else {
                    addVariableAtPosition(canvasX, canvasY, currentPage);
                }
            } else if (currentMode === 'image') {
                addImageAtPosition(canvasX, canvasY, currentPage);
            } else if (currentMode === 'shape') {
                handleShapeClick(canvasX, canvasY, currentPage);
            }
        }

        function addVariableAtPosition(canvasX, canvasY, page) {
            const pdfCoords = canvasToPDFCoordinates(canvasX, canvasY, page);

            const variableName = `var_${variables.length + 1}`;
            const variable = {
                name: variableName,
                x: pdfCoords.x,
                y: pdfCoords.y,
                page: page,
                fontSize: 12,
                type: 'simple',
                conditionalCoordinates: []
            };

            variables.push(variable);
            updateVariablesList();
            updateConfiguration();
            renderAllOverlays();
            
            showNotification(`Added variable "${variableName}" at PDF coordinates (${pdfCoords.x}, ${pdfCoords.y})`);
        }

        function addImageAtPosition(canvasX, canvasY, page) {
            if (uploadedImages.length === 0) {
                showNotification('Please upload images first', 'error');
                return;
            }

            let selectedImage;
            if (uploadedImages.length === 1) {
                selectedImage = uploadedImages[0];
            } else {
                const imageNames = uploadedImages.map((img, i) => `${i + 1}. ${img.filename}`).join('\n');
                const choice = prompt(`Select an image:\n${imageNames}`);
                const choiceIndex = parseInt(choice) - 1;
                
                if (choiceIndex >= 0 && choiceIndex < uploadedImages.length) {
                    selectedImage = uploadedImages[choiceIndex];
                } else {
                    return;
                }
            }

            const imageName = prompt('Enter variable name for this image (e.g., "logo", "signature"):', `image_${images.length + 1}`);
            if (!imageName) return;

            const pdfCoords = canvasToPDFCoordinates(canvasX, canvasY, page);
            
            const image = {
                name: imageName,
                filename: selectedImage.filename,
                x: pdfCoords.x,
                y: pdfCoords.y,
                page: page,
                width: 100,
                height: 100
            };

            images.push(image);
            updateImagesList();
            updateConfiguration();
            renderAllOverlays();
            showNotification(`Added image variable "${imageName}" at PDF coordinates (${pdfCoords.x}, ${pdfCoords.y})`);
        }

        function handleShapeClick(canvasX, canvasY, page) {
            if (lineDrawingState === 'waiting_for_start') {
                const pdfCoords = canvasToPDFCoordinates(canvasX, canvasY, page);
                tempLineStart = {
                    x: pdfCoords.x,
                    y: pdfCoords.y,
                    canvasX: canvasX,
                    canvasY: canvasY
                };
                lineDrawingState = 'waiting_for_end';
                
                showTemporaryLinePoint(canvasX, canvasY, 'start');
                updateModeInstructions();
                showNotification('Line start point set. Click again to set end point.', 'success');
                
            } else if (lineDrawingState === 'waiting_for_end') {
                const pdfCoords = canvasToPDFCoordinates(canvasX, canvasY, page);
                
                const shape = {
                    type: 'line',
                    x: tempLineStart.x,
                    y: tempLineStart.y,
                    page: page,
                    width: 50,
                    height: 50,
                    color: '#000000',
                    fill: false,
                    stroke_width: 2,
                    radius: 25,
                    end_x: pdfCoords.x,
                    end_y: pdfCoords.y
                };

                shapes.push(shape);
                updateShapesList();
                updateConfiguration();
                renderAllOverlays();
                
                lineDrawingState = null;
                tempLineStart = null;
                removeTemporaryLinePoints();
                updateModeInstructions();
                showNotification('Line created successfully!', 'success');
                
            } else {
                const shapeType = prompt('Select shape type:\n1. Rectangle\n2. Circle\n3. Line (two-point)');
                let type;
                
                switch(shapeType) {
                    case '1': type = 'rectangle'; break;
                    case '2': type = 'circle'; break;
                    case '3': 
                        type = 'line';
                        lineDrawingState = 'waiting_for_start';
                        updateModeInstructions();
                        showNotification('Click on the PDF to set line start point.', 'success');
                        return;
                    default: return;
                }

                const pdfCoords = canvasToPDFCoordinates(canvasX, canvasY, page);
                
                const shape = {
                    type: type,
                    x: pdfCoords.x,
                    y: pdfCoords.y,
                    page: page,
                    width: 50,
                    height: 50,
                    color: '#000000',
                    fill: false,
                    stroke_width: 1,
                    radius: 25,
                    end_x: pdfCoords.x + 50,
                    end_y: pdfCoords.y
                };

                shapes.push(shape);
                updateShapesList();
                updateConfiguration();
                renderAllOverlays();
                showNotification(`Added ${type} at PDF coordinates (${pdfCoords.x}, ${pdfCoords.y})`);
            }
        }

        function showTemporaryLinePoint(canvasX, canvasY, pointType) {
            removeTemporaryLinePoints();
            
            const canvasRect = pdfCanvas.getBoundingClientRect();
            const viewerRect = pdfViewer.getBoundingClientRect();
            const offsetX = canvasRect.left - viewerRect.left;
            const offsetY = canvasRect.top - viewerRect.top;
            
            const tempPoint = document.createElement('div');
            tempPoint.className = 'temp-line-point';
            tempPoint.id = `temp-${pointType}-point`;
            tempPoint.style.position = 'absolute';
            tempPoint.style.left = (canvasX + offsetX) + 'px';
            tempPoint.style.top = (canvasY + offsetY) + 'px';
            tempPoint.style.width = '12px';
            tempPoint.style.height = '12px';
            tempPoint.style.borderRadius = '50%';
            tempPoint.style.background = pointType === 'start' ? '#ff4444' : '#44ff44';
            tempPoint.style.border = '2px solid white';
            tempPoint.style.transform = 'translate(-50%, -50%)';
            tempPoint.style.zIndex = '1001';
            tempPoint.style.pointerEvents = 'none';
            tempPoint.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';
            
            const label = document.createElement('div');
            label.style.position = 'absolute';
            label.style.top = '-25px';
            label.style.left = '50%';
            label.style.transform = 'translateX(-50%)';
            label.style.background = 'rgba(0,0,0,0.8)';
            label.style.color = 'white';
            label.style.padding = '2px 6px';
            label.style.borderRadius = '3px';
            label.style.fontSize = '10px';
            label.style.whiteSpace = 'nowrap';
            label.textContent = pointType === 'start' ? 'START' : 'END';
            tempPoint.appendChild(label);
            
            pdfViewer.appendChild(tempPoint);
        }

        function removeTemporaryLinePoints() {
            const tempPoints = pdfViewer.querySelectorAll('.temp-line-point');
            tempPoints.forEach(point => point.remove());
        }

        function addConditionalCoordinateByClick(x, y) {
            const conditionalVars = variables.filter(v => v.type === 'conditional' && v.page === currentPage);

            if (conditionalVars.length === 0) {
                showNotification('No conditional variables on this page. Create a conditional variable first.', 'error');
                return;
            }

            if (conditionalVars.length === 1) {
                const varIndex = variables.indexOf(conditionalVars[0]);
                addConditionalCoordinate(varIndex);
                const lastCondIndex = variables[varIndex].conditionalCoordinates.length - 1;
                updateConditionalCoordinate(varIndex, lastCondIndex, 'x', x);
                updateConditionalCoordinate(varIndex, lastCondIndex, 'y', y);
                updateVariablesList();
                showNotification(`Added conditional coordinate to "${conditionalVars[0].name}" at (${x}, ${y})`);
            } else {
                const varNames = conditionalVars.map((v, i) => `${i + 1}. ${v.name}`).join('\n');
                const choice = prompt(`Multiple conditional variables found. Enter the number for:\n${varNames}`);
                const choiceIndex = parseInt(choice) - 1;

                if (choiceIndex >= 0 && choiceIndex < conditionalVars.length) {
                    const varIndex = variables.indexOf(conditionalVars[choiceIndex]);
                    addConditionalCoordinate(varIndex);
                    const lastCondIndex = variables[varIndex].conditionalCoordinates.length - 1;
                    updateConditionalCoordinate(varIndex, lastCondIndex, 'x', x);
                    updateConditionalCoordinate(varIndex, lastCondIndex, 'y', y);
                    updateVariablesList();
                    showNotification(`Added conditional coordinate to "${conditionalVars[choiceIndex].name}" at (${x}, ${y})`);
                }
            }
        }

        function addVariable() {
            const pdfPageDim = pdfPageDimensions[currentPage] || { width: 612, height: 792 };
            const centerX = Math.round(pdfPageDim.width / 2);
            const centerY = Math.round(pdfPageDim.height / 2);

            const variable = {
                name: `var_${variables.length + 1}`,
                x: centerX,
                y: centerY,
                page: currentPage,
                fontSize: 12,
                type: 'simple',
                conditionalCoordinates: []
            };

            variables.push(variable);
            updateAllLists();
            updateConfiguration();
            renderAllOverlays();
        }

        function removeVariable(index) {
            variables.splice(index, 1);
            updateAllLists();
            updateConfiguration();
            renderAllOverlays();
        }

        function removeImage(index) {
            images.splice(index, 1);
            updateAllLists();
            updateConfiguration();
            renderAllOverlays();
        }

        function removeShape(index) {
            shapes.splice(index, 1);
            updateAllLists();
            updateConfiguration();
            renderAllOverlays();
        }

        function updateVariable(index, field, value) {
            if (variables[index]) {
                if (field === 'fontSize' || field === 'x' || field === 'y' || field === 'page') {
                    variables[index][field] = parseInt(value) || 0;
                } else {
                    variables[index][field] = value;
                }

                if (field === 'type' && value === 'conditional' && !variables[index].conditionalCoordinates.length) {
                    variables[index].conditionalCoordinates = [{
                        if_value: '',
                        print_pattern: '*',
                        x: variables[index].x,
                        y: variables[index].y
                    }];
                }

                updateVariablesList();
                updateConfiguration();
                if (field === 'x' || field === 'y' || field === 'page') {
                    renderAllOverlays();
                }
            }
        }

        function updateImage(index, field, value) {
            if (images[index]) {
                if (field === 'width' || field === 'height' || field === 'x' || field === 'y' || field === 'page') {
                    images[index][field] = parseInt(value) || 0;
                } else {
                    images[index][field] = value;
                }

                updateImagesList();
                updateConfiguration();
                if (field === 'x' || field === 'y' || field === 'page') {
                    renderAllOverlays();
                }
            }
        }

        function updateShape(index, field, value) {
            if (shapes[index]) {
                if (field === 'width' || field === 'height' || field === 'x' || field === 'y' || field === 'page' || 
                    field === 'radius' || field === 'end_x' || field === 'end_y' || field === 'stroke_width') {
                    shapes[index][field] = parseInt(value) || 0;
                } else if (field === 'fill') {
                    shapes[index][field] = value === 'true';
                } else {
                    shapes[index][field] = value;
                }

                updateShapesList();
                updateConfiguration();
                if (field === 'x' || field === 'y' || field === 'page' || field === 'end_x' || field === 'end_y') {
                    renderAllOverlays();
                }
            }
        }

        function addConditionalCoordinate(variableIndex) {
            if (variables[variableIndex]) {
                const pdfPageDim = pdfPageDimensions[variables[variableIndex].page] || { width: 612, height: 792 };
                variables[variableIndex].conditionalCoordinates.push({
                    if_value: '',
                    print_pattern: '*',
                    x: Math.round(pdfPageDim.width / 2),
                    y: Math.round(pdfPageDim.height / 2)
                });
                updateVariablesList();
                updateConfiguration();
                renderAllOverlays();
            }
        }

        function removeConditionalCoordinate(variableIndex, condIndex) {
            if (variables[variableIndex] && variables[variableIndex].conditionalCoordinates[condIndex]) {
                variables[variableIndex].conditionalCoordinates.splice(condIndex, 1);
                updateVariablesList();
                updateConfiguration();
                renderAllOverlays();
            }
        }

        function updateConditionalCoordinate(variableIndex, condIndex, field, value) {
            if (variables[variableIndex] && variables[variableIndex].conditionalCoordinates[condIndex]) {
                if (field === 'x' || field === 'y') {
                    variables[variableIndex].conditionalCoordinates[condIndex][field] = parseInt(value) || 0;
                } else {
                    variables[variableIndex].conditionalCoordinates[condIndex][field] = value;
                }
                updateConfiguration();
                if (field === 'x' || field === 'y') {
                    renderAllOverlays();
                }
            }
        }

        function updateAllLists() {
            updateVariablesList();
            updateImagesList();
            updateShapesList();
        }

        function updateVariablesList() {
            variablesList.innerHTML = '';

            variables.forEach((variable, index) => {
                const div = document.createElement('div');
                div.className = 'variable-item';

                let conditionalSection = '';
                if (variable.type === 'conditional') {
                    let conditionalInputs = '';
                    variable.conditionalCoordinates.forEach((cond, condIndex) => {
                        conditionalInputs += `
                            <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin-bottom: 10px; border: 1px solid #ffeaa7;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                    <strong>Condition ${condIndex + 1}</strong>
                                    <button type="button" onclick="removeConditionalCoordinate(${index}, ${condIndex})" 
                                            style="background: #dc3545; color: white; border: none; padding: 3px 8px; border-radius: 3px; font-size: 0.75rem;">Remove</button>
                                </div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px;">
                                    <div>
                                        <label style="font-size: 0.8rem; font-weight: 600;">If Value:</label>
                                        <input type="text" class="form-control" style="padding: 6px;" value="${cond.if_value || ''}" 
                                               placeholder="e.g., Male, Yes, Option1"
                                               onchange="updateConditionalCoordinate(${index}, ${condIndex}, 'if_value', this.value)"
                                               oninput="updateConditionalCoordinate(${index}, ${condIndex}, 'if_value', this.value)">
                                    </div>
                                    <div>
                                        <label style="font-size: 0.8rem; font-weight: 600;">Print Pattern:</label>
                                        <input type="text" class="form-control" style="padding: 6px;" value="${cond.print_pattern || '*'}" 
                                               placeholder="e.g., *, ✓, X"
                                               onchange="updateConditionalCoordinate(${index}, ${condIndex}, 'print_pattern', this.value)"
                                               oninput="updateConditionalCoordinate(${index}, ${condIndex}, 'print_pattern', this.value)">
                                    </div>
                                </div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                    <div>
                                        <label style="font-size: 0.8rem; font-weight: 600;">X Coordinate:</label>
                                        <input type="number" class="form-control" style="padding: 6px;" value="${cond.x || 0}"
                                               onchange="updateConditionalCoordinate(${index}, ${condIndex}, 'x', this.value)"
                                               oninput="updateConditionalCoordinate(${index}, ${condIndex}, 'x', this.value)">
                                    </div>
                                    <div>
                                        <label style="font-size: 0.8rem; font-weight: 600;">Y Coordinate:</label>
                                        <input type="number" class="form-control" style="padding: 6px;" value="${cond.y || 0}"
                                               onchange="updateConditionalCoordinate(${index}, ${condIndex}, 'y', this.value)"
                                               oninput="updateConditionalCoordinate(${index}, ${condIndex}, 'y', this.value)">
                                    </div>
                                </div>
                            </div>
                        `;
                    });

                    conditionalSection = `
                        <div style="margin-top: 15px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <label style="font-weight: 600; color: #ff8c00;">Conditional Coordinates:</label>
                                <button type="button" onclick="addConditionalCoordinate(${index})"
                                        style="background: #28a745; color: white; border: none; padding: 5px 10px; border-radius: 5px; font-size: 0.8rem;">+ Add Condition</button>
                            </div>
                            ${conditionalInputs}
                        </div>
                    `;
                }

                div.innerHTML = `
                    <div class="variable-header">
                        <strong>Variable ${index + 1}</strong>
                        <button class="remove-btn" onclick="removeVariable(${index})">Remove</button>
                    </div>
                    <div class="form-group">
                        <label>Variable Name:</label>
                        <input type="text" class="form-control" value="${variable.name}" 
                               onchange="updateVariable(${index}, 'name', this.value)">
                    </div>
                    <div class="form-group">
                        <label>Variable Type:</label>
                        <select class="form-control" onchange="updateVariable(${index}, 'type', this.value)">
                            <option value="simple" ${variable.type === 'simple' ? 'selected' : ''}>Simple (Single Position)</option>
                            <option value="conditional" ${variable.type === 'conditional' ? 'selected' : ''}>Conditional (Multiple Positions)</option>
                        </select>
                    </div>

                    ${variable.type === 'simple' ? `
                        <div class="coordinate-display">
                            <strong>📍 Coordinates</strong>
                            <br>Page: ${variable.page} (Config: ${variable.page - 1})
                            <br>PDF Position: X=${variable.x}, Y=${variable.y}
                        </div>
                        <div class="coordinate-debug">
                            <strong>🔧 Debug Info:</strong>
                            <br>Canvas Size: ${pdfCanvas ? pdfCanvas.width + 'x' + pdfCanvas.height : 'N/A'}
                            <br>PDF Size: ${pdfPageDimensions[variable.page] ? pdfPageDimensions[variable.page].width + 'x' + pdfPageDimensions[variable.page].height : 'N/A'}
                            <br>Scale Factors: ${pdfCanvas && pdfPageDimensions[variable.page] ? 
                                `X=${(pdfPageDimensions[variable.page].width / pdfCanvas.width).toFixed(3)}, Y=${(pdfPageDimensions[variable.page].height / pdfCanvas.height).toFixed(3)}` : 'N/A'}
                        </div>
                        <div class="form-group">
                            <label>Page Number:</label>
                            <input type="number" class="form-control" value="${variable.page}" min="1" max="${totalPages || 999}"
                                   onchange="updateVariable(${index}, 'page', this.value)">
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <div class="form-group" style="flex: 1;">
                                <label>X Coordinate (PDF):</label>
                                <input type="number" class="form-control" value="${variable.x}"
                                       onchange="updateVariable(${index}, 'x', this.value)">
                            </div>
                            <div class="form-group" style="flex: 1;">
                                <label>Y Coordinate (PDF):</label>
                                <input type="number" class="form-control" value="${variable.y}"
                                       onchange="updateVariable(${index}, 'y', this.value)">
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Font Size:</label>
                            <input type="number" class="form-control" value="${variable.fontSize}" min="6" max="72"
                                   onchange="updateVariable(${index}, 'fontSize', this.value)">
                        </div>
                    ` : ''}

                    ${conditionalSection}
                `;
                variablesList.appendChild(div);
            });
        }

        function updateImagesList() {
            imagesList.innerHTML = '';

            images.forEach((image, index) => {
                const div = document.createElement('div');
                div.className = 'image-item';

                div.innerHTML = `
                    <div class="image-header">
                        <strong>🖼️ Image ${index + 1}</strong>
                        <button class="remove-btn" onclick="removeImage(${index})">Remove</button>
                    </div>
                    <div class="coordinate-display">
                        <strong>📍 Image Details</strong>
                        <br>Variable Name: ${image.name}
                        <br>Reference File: ${image.filename}
                        <br>Page: ${image.page} | Position: (${image.x}, ${image.y})
                        <br>Size: ${image.width} x ${image.height}
                        <br><small>💡 Add "${image.name}" key with image URL to sample data</small>
                        <br><small style="color: #007bff;">Uploaded URL: ${(() => {
                            const uploadedImg = uploadedImages.find(img => img.filename === image.filename);
                            return uploadedImg ? window.location.origin + uploadedImg.url : 'Not found';
                        })()}</small>
                    </div>
                    <div class="form-group">
                        <label>Variable Name:</label>
                        <input type="text" class="form-control" value="${image.name}" 
                               placeholder="e.g., logo, signature"
                               onchange="updateImage(${index}, 'name', this.value)">
                    </div>
                    <div class="form-group">
                        <label>Reference Image File:</label>
                        <select class="form-control" onchange="updateImage(${index}, 'filename', this.value)">
                            ${uploadedImages.map(img => 
                                `<option value="${img.filename}" ${img.filename === image.filename ? 'selected' : ''}>${img.filename}</option>`
                            ).join('')}
                        </select>
                        <small style="color: #666; font-size: 0.8rem;">This is just for reference. Actual image comes from sample data URL.</small>
                    </div>
                    <div class="form-group">
                        <label>Page Number:</label>
                        <input type="number" class="form-control" value="${image.page}" min="1" max="${totalPages || 999}"
                               onchange="updateImage(${index}, 'page', this.value)">
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <div class="form-group" style="flex: 1;">
                            <label>X Coordinate (PDF):</label>
                            <input type="number" class="form-control" value="${image.x}"
                                   onchange="updateImage(${index}, 'x', this.value)">
                        </div>
                        <div class="form-group" style="flex: 1;">
                            <label>Y Coordinate (PDF):</label>
                            <input type="number" class="form-control" value="${image.y}"
                                   onchange="updateImage(${index}, 'y', this.value)">
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <div class="form-group" style="flex: 1;">
                            <label>Width:</label>
                            <input type="number" class="form-control" value="${image.width}" min="10"
                                   onchange="updateImage(${index}, 'width', this.value)">
                        </div>
                        <div class="form-group" style="flex: 1;">
                            <label>Height:</label>
                            <input type="number" class="form-control" value="${image.height}" min="10"
                                   onchange="updateImage(${index}, 'height', this.value)">
                        </div>
                    </div>
                `;
                imagesList.appendChild(div);
            });

            if (images.length === 0) {
                imagesList.innerHTML = '<div style="text-align: center; color: #666;">No image overlays added yet. Switch to Image mode and click on the PDF to add images.</div>';
            }
        }

        function updateShapesList() {
            shapesList.innerHTML = '';

            shapes.forEach((shape, index) => {
                const div = document.createElement('div');
                div.className = 'shape-item';

                let shapeSpecificFields = '';
                if (shape.type === 'circle') {
                    shapeSpecificFields = `
                        <div class="form-group">
                            <label>Radius:</label>
                            <input type="number" class="form-control" value="${shape.radius || 25}" min="5"
                                   onchange="updateShape(${index}, 'radius', this.value)">
                        </div>
                    `;
                } else if (shape.type === 'line') {
                    shapeSpecificFields = `
                        <div style="display: flex; gap: 10px;">
                            <div class="form-group" style="flex: 1;">
                                <label>End X (PDF):</label>
                                <input type="number" class="form-control" value="${shape.end_x || shape.x + 50}"
                                       onchange="updateShape(${index}, 'end_x', this.value)">
                            </div>
                            <div class="form-group" style="flex: 1;">
                                <label>End Y (PDF):</label>
                                <input type="number" class="form-control" value="${shape.end_y || shape.y}"
                                       onchange="updateShape(${index}, 'end_y', this.value)">
                            </div>
                        </div>
                    `;
                } else {
                    shapeSpecificFields = `
                        <div style="display: flex; gap: 10px;">
                            <div class="form-group" style="flex: 1;">
                                <label>Width:</label>
                                <input type="number" class="form-control" value="${shape.width}" min="5"
                                       onchange="updateShape(${index}, 'width', this.value)">
                            </div>
                            <div class="form-group" style="flex: 1;">
                                <label>Height:</label>
                                <input type="number" class="form-control" value="${shape.height}" min="5"
                                       onchange="updateShape(${index}, 'height', this.value)">
                            </div>
                        </div>
                    `;
                }

                div.innerHTML = `
                    <div class="shape-header">
                        <strong>🔲 ${shape.type} ${index + 1}</strong>
                        <button class="remove-btn" onclick="removeShape(${index})">Remove</button>
                    </div>
                    <div class="coordinate-display">
                        <strong>📍 Shape Details</strong>
                        <br>Type: ${shape.type} | Page: ${shape.page}
                        <br>Position: (${shape.x}, ${shape.y}) PDF | (${(shape.x/72).toFixed(2)}", ${(shape.y/72).toFixed(2)}") inches
                        <br>Color: ${shape.color} | Fill: ${shape.fill ? 'Yes' : 'No'}
                        ${shape.type === 'line' ? `<br>End: (${shape.end_x}, ${shape.end_y}) PDF | (${(shape.end_x/72).toFixed(2)}", ${(shape.end_y/72).toFixed(2)}") inches` : ''}
                        ${shape.type === 'line' ? `<br>Length: ${Math.sqrt(Math.pow(shape.end_x - shape.x, 2) + Math.pow(shape.end_y - shape.y, 2)).toFixed(1)} points` : ''}
                    </div>
                    <div class="form-group">
                        <label>Shape Type:</label>
                        <select class="form-control" onchange="updateShape(${index}, 'type', this.value)">
                            <option value="rectangle" ${shape.type === 'rectangle' ? 'selected' : ''}>Rectangle</option>
                            <option value="circle" ${shape.type === 'circle' ? 'selected' : ''}>Circle</option>
                            <option value="line" ${shape.type === 'line' ? 'selected' : ''}>Line</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Page Number:</label>
                        <input type="number" class="form-control" value="${shape.page}" min="1" max="${totalPages || 999}"
                               onchange="updateShape(${index}, 'page', this.value)">
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <div class="form-group" style="flex: 1;">
                            <label>${shape.type === 'line' ? 'Start X (PDF)' : 'X Coordinate (PDF)'}:</label>
                            <input type="number" class="form-control" value="${shape.x}"
                                   onchange="updateShape(${index}, 'x', this.value)">
                        </div>
                        <div class="form-group" style="flex: 1;">
                            <label>${shape.type === 'line' ? 'Start Y (PDF)' : 'Y Coordinate (PDF)'}:</label>
                            <input type="number" class="form-control" value="${shape.y}"
                                   onchange="updateShape(${index}, 'y', this.value)">
                        </div>
                    </div>
                    ${shapeSpecificFields}
                    <div style="display: flex; gap: 10px;">
                        <div class="form-group" style="flex: 1;">
                            <label>Color:</label>
                            <input type="color" class="form-control" value="${shape.color}" style="height: 40px;"
                                   onchange="updateShape(${index}, 'color', this.value)">
                        </div>
                        <div class="form-group" style="flex: 1;">
                            <label>Stroke Width:</label>
                            <input type="number" class="form-control" value="${shape.stroke_width}" min="1" max="10"
                                   onchange="updateShape(${index}, 'stroke_width', this.value)">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Fill Shape:</label>
                        <select class="form-control" onchange="updateShape(${index}, 'fill', this.value)" ${shape.type === 'line' ? 'disabled' : ''}>
                            <option value="false" ${!shape.fill ? 'selected' : ''}>No (Outline only)</option>
                            <option value="true" ${shape.fill ? 'selected' : ''}>Yes (Filled)</option>
                        </select>
                        ${shape.type === 'line' ? '<small style="color: #666;">Lines cannot be filled</small>' : ''}
                    </div>
                    ${shape.type === 'line' ? `
                        <div style="margin-top: 15px; padding: 10px; background: #e3f2fd; border-radius: 5px;">
                            <small><strong>💡 Line Tips:</strong> 
                            <br>• Use "Shape Mode" and select "Line (two-point)" for interactive drawing
                            <br>• Click twice on PDF: first for start point, second for end point
                            <br>• Manually adjust coordinates above for precise positioning</small>
                        </div>
                    ` : ''}
                `;
                shapesList.appendChild(div);
            });

            if (shapes.length === 0) {
                shapesList.innerHTML = '<div style="text-align: center; color: #666;">No shape overlays added yet. Switch to Shape mode and click on the PDF to add shapes.</div>';
            }
        }

        function updateConfiguration() {
            if (variables.length === 0 && images.length === 0 && shapes.length === 0) {
                configOutput.textContent = 'Click on the PDF to start adding elements...';
                return;
            }

            const pageGroups = {};
            
            variables.forEach(variable => {
                const zeroBasedPage = variable.page - 1;
                if (!pageGroups[zeroBasedPage]) {
                    pageGroups[zeroBasedPage] = { variables: [], images: [] };
                }

                if (variable.type === 'simple') {
                    pageGroups[zeroBasedPage].variables.push({
                        name: variable.name,
                        "x-coordinate": variable.x,
                        "y-coordinate": variable.y,
                        font_size: variable.fontSize
                    });
                } else if (variable.type === 'conditional') {
                    const conditionalVar = {
                        name: variable.name,
                        conditional_coordinates: variable.conditionalCoordinates.map(cond => ({
                            if_value: cond.if_value,
                            print_pattern: cond.print_pattern,
                            "x-coordinate": cond.x,
                            "y-coordinate": cond.y
                        }))
                    };
                    pageGroups[zeroBasedPage].variables.push(conditionalVar);
                }
            });

            images.forEach(image => {
                const zeroBasedPage = image.page - 1;
                if (!pageGroups[zeroBasedPage]) {
                    pageGroups[zeroBasedPage] = { variables: [], images: [] };
                }

                pageGroups[zeroBasedPage].variables.push({
                    name: image.name,
                    image: {
                        "x-coordinate": image.x,
                        "y-coordinate": image.y,
                        width: image.width,
                        height: image.height
                    }
                });
            });

            shapes.forEach(shape => {
                const zeroBasedPage = shape.page - 1;
                if (!pageGroups[zeroBasedPage]) {
                    pageGroups[zeroBasedPage] = { variables: [], images: [], shapes: [] };
                }

                const colorHex = shape.color.replace('#', '');
                const r = parseInt(colorHex.substring(0, 2), 16) / 255.0;
                const g = parseInt(colorHex.substring(2, 4), 16) / 255.0;
                const b = parseInt(colorHex.substring(4, 6), 16) / 255.0;

                const x0_inches = shape.x / 72.0;
                const y0_inches = shape.y / 72.0;

                const shapeConfig = {
                    name: 'draw_shape',
                    draw_shape: {
                        r: parseFloat(r.toFixed(3)),
                        g: parseFloat(g.toFixed(3)),
                        b: parseFloat(b.toFixed(3)),
                        shape: shape.type.charAt(0).toUpperCase() + shape.type.slice(1),
                        'x0-coordinate': parseFloat(x0_inches.toFixed(3)),
                        'y0-coordinate': parseFloat(y0_inches.toFixed(3))
                    }
                };

                if (shape.type === 'rectangle') {
                    shapeConfig.draw_shape['x1-coordinate'] = parseFloat(((shape.x + shape.width) / 72.0).toFixed(3));
                    shapeConfig.draw_shape['y1-coordinate'] = parseFloat(((shape.y + shape.height) / 72.0).toFixed(3));
                } else if (shape.type === 'circle') {
                    const radiusInches = shape.radius / 72.0;
                    shapeConfig.draw_shape['x1-coordinate'] = parseFloat((x0_inches + radiusInches).toFixed(3));
                    shapeConfig.draw_shape['y1-coordinate'] = parseFloat((y0_inches + radiusInches).toFixed(3));
                } else if (shape.type === 'line') {
                    shapeConfig.draw_shape['x1-coordinate'] = parseFloat((shape.end_x / 72.0).toFixed(3));
                    shapeConfig.draw_shape['y1-coordinate'] = parseFloat((shape.end_y / 72.0).toFixed(3));
                }

                pageGroups[zeroBasedPage].variables.push(shapeConfig);
            });

            const configuration = Object.keys(pageGroups).map(page => ({
                page_number: parseInt(page),
                variables: pageGroups[page].variables
            }));

            configOutput.textContent = JSON.stringify(configuration, null, 2);
        }

        function loadFromConfiguration() {
            try {
                const configText = configOutput.value || configOutput.textContent;
                if (!configText || configText === 'Click on the PDF to start adding elements...') {
                    showNotification('No configuration to load', 'error');
                    return;
                }

                const config = JSON.parse(configText);
                if (!Array.isArray(config)) {
                    showNotification('Invalid configuration format - must be an array', 'error');
                    return;
                }

                variables = [];
                images = [];
                shapes = [];

                config.forEach(pageConfig => {
                    const displayPage = pageConfig.page_number + 1;

                    if (pageConfig.variables && Array.isArray(pageConfig.variables)) {
                        pageConfig.variables.forEach(variable => {
                            if (variable.name === 'draw_shape' && variable.draw_shape) {
                                const drawShape = variable.draw_shape;
                                
                                const r = Math.round((drawShape.r || 0) * 255);
                                const g = Math.round((drawShape.g || 0) * 255);
                                const b = Math.round((drawShape.b || 0) * 255);
                                const colorHex = '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
                                
                                const x0 = Math.round((drawShape['x0-coordinate'] || 0) * 72);
                                const y0 = Math.round((drawShape['y0-coordinate'] || 0) * 72);
                                const x1 = Math.round((drawShape['x1-coordinate'] || 0) * 72);
                                const y1 = Math.round((drawShape['y1-coordinate'] || 0) * 72);
                                
                                const newShape = {
                                    type: (drawShape.shape || 'rectangle').toLowerCase(),
                                    x: x0,
                                    y: y0,
                                    page: displayPage,
                                    color: colorHex,
                                    fill: false,
                                    stroke_width: 1
                                };
                                
                                if (newShape.type === 'rectangle') {
                                    newShape.width = Math.abs(x1 - x0);
                                    newShape.height = Math.abs(y1 - y0);
                                } else if (newShape.type === 'circle') {
                                    newShape.radius = Math.abs(x1 - x0);
                                } else if (newShape.type === 'line') {
                                    newShape.end_x = x1;
                                    newShape.end_y = y1;
                                }
                                
                                shapes.push(newShape);
                            } else if (variable.conditional_coordinates) {
                                const newVar = {
                                    name: variable.name,
                                    x: 0,
                                    y: 0,
                                    page: displayPage,
                                    fontSize: 12,
                                    type: 'conditional',
                                    conditionalCoordinates: variable.conditional_coordinates.map(cond => ({
                                        if_value: cond.if_value || '',
                                        print_pattern: cond.print_pattern || '*',
                                        x: cond['x-coordinate'] || 0,
                                        y: cond['y-coordinate'] || 0
                                    }))
                                };
                                variables.push(newVar);
                            } else if (variable.image) {
                                const newImage = {
                                    name: variable.name,
                                    filename: 'placeholder.png',
                                    x: variable.image['x-coordinate'] || 0,
                                    y: variable.image['y-coordinate'] || 0,
                                    page: displayPage,
                                    width: variable.image.width || 100,
                                    height: variable.image.height || 100
                                };
                                images.push(newImage);
                            } else {
                                const newVar = {
                                    name: variable.name,
                                    x: variable['x-coordinate'] || 0,
                                    y: variable['y-coordinate'] || 0,
                                    page: displayPage,
                                    fontSize: variable.font_size || 12,
                                    type: 'simple',
                                    conditionalCoordinates: []
                                };
                                variables.push(newVar);
                            }
                        });
                    }
                });

                updateAllLists();
                renderAllOverlays();
                showNotification(`Configuration loaded! ${variables.length} variables, ${images.length} images, ${shapes.length} shapes imported.`);

            } catch (error) {
                showNotification('Invalid JSON configuration: ' + error.message, 'error');
                console.error('Config parsing error:', error);
            }
        }

        function copyConfiguration() {
            if (configOutput.textContent && configOutput.textContent !== 'Click on the PDF to start adding elements...') {
                navigator.clipboard.writeText(configOutput.textContent).then(() => {
                    showNotification('Configuration copied to clipboard!');
                });
            }
        }

        function saveConfiguration() {
            if (variables.length === 0 && images.length === 0 && shapes.length === 0) {
                showNotification('No configuration to save', 'error');
                return;
            }

            const configName = prompt('Enter configuration name:', `config_${new Date().toISOString().slice(0,19).replace(/:/g, '-')}`);
            if (!configName) return;

            const configText = configOutput.textContent;
            
            fetch('/api/save-config', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    name: configName,
                    configuration: JSON.parse(configText)
                })
            })
            .then(response => response.json())
            .then(result => {
                if (result.success) {
                    showNotification(result.message);
                } else {
                    showNotification(result.error, 'error');
                }
            })
            .catch(error => {
                showNotification('Failed to save configuration: ' + error.message, 'error');
            });
        }

        function prefillSampleData() {
            const variableNames = variables.map(v => v.name);
            const imageNames = images.map(img => img.name);
            const allNames = [...variableNames, ...imageNames];
            
            if (allNames.length === 0) {
                showNotification('Please add some variables or images first by clicking on the PDF.', 'error');
                return;
            }

            const sampleObj = {};
            
            variableNames.forEach(name => {
                if (name.toLowerCase().includes('gender')) {
                    sampleObj[name] = 'Male';
                } else if (name.toLowerCase().includes('name')) {
                    sampleObj[name] = 'John Doe';
                } else if (name.toLowerCase().includes('email')) {
                    sampleObj[name] = 'john.doe@example.com';
                } else if (name.toLowerCase().includes('date')) {
                    sampleObj[name] = new Date().toISOString().split('T')[0];
                } else if (name.toLowerCase().includes('phone')) {
                    sampleObj[name] = '+1-234-567-8900';
                } else if (name.toLowerCase().includes('address')) {
                    sampleObj[name] = '123 Main St, City, State 12345';
                } else if (name.toLowerCase().includes('company')) {
                    sampleObj[name] = 'Example Company Inc.';
                } else if (name.toLowerCase().includes('status') || name.toLowerCase().includes('type')) {
                    sampleObj[name] = 'Active';
                } else {
                    sampleObj[name] = `Sample ${name}`;
                }
            });
            
            images.forEach(image => {
                const uploadedImage = uploadedImages.find(img => img.filename === image.filename);
                if (uploadedImage && uploadedImage.url) {
                    sampleObj[image.name] = window.location.origin + uploadedImage.url;
                } else {
                    if (image.name.toLowerCase().includes('logo')) {
                        sampleObj[image.name] = 'https://example.com/logo.png';
                    } else if (image.name.toLowerCase().includes('signature')) {
                        sampleObj[image.name] = 'https://example.com/signature.png';
                    } else if (image.name.toLowerCase().includes('photo')) {
                        sampleObj[image.name] = 'https://example.com/photo.jpg';
                    } else {
                        sampleObj[image.name] = `https://example.com/${image.name}.png`;
                    }
                }
            });

            sampleData.value = JSON.stringify(sampleObj, null, 2);
            showNotification('Sample data generated with actual uploaded image URLs!');
        }

        async function processDocument() {
            if (!pdfUploaded) {
                showNotification('Please upload a PDF first', 'error');
                return;
            }

            if (variables.length === 0 && images.length === 0 && shapes.length === 0) {
                showNotification('Please add some elements first', 'error');
                return;
            }

            let parsedSampleData;
            try {
                parsedSampleData = JSON.parse(sampleData.value || '{}');
            } catch (error) {
                showNotification('Invalid JSON in sample data', 'error');
                return;
            }

            showLoading(processLoading);
            processBtn.disabled = true;

            try {
                const configText = configOutput.textContent;
                const configuration = JSON.parse(configText);

                const response = await fetch('/api/process', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        configuration: configuration,
                        sample_data: parsedSampleData
                    })
                });

                const result = await response.json();

                if (result.success) {
                    showNotification('PDF processed successfully with all overlays!');
                    processedFilename = result.output_filename;
                    downloadSection.style.display = 'block';
                } else {
                    showNotification(result.error, 'error');
                }
            } catch (error) {
                showNotification('Processing failed: ' + error.message, 'error');
            } finally {
                hideLoading(processLoading);
                processBtn.disabled = false;
            }
        }

        function downloadProcessedPDF() {
            if (!processedFilename) {
                showNotification('No processed file available', 'error');
                return;
            }

            window.open(`/api/download/${processedFilename}`, '_blank');
        }

        async function testImageAccessibility() {
            if (uploadedImages.length === 0) {
                showNotification('No images uploaded to test', 'error');
                return;
            }

            showNotification('Testing image accessibility...', 'success');
            
            for (const img of uploadedImages) {
                try {
                    const response = await fetch(`/api/test-image/${img.filename}`);
                    const result = await response.json();
                    
                    console.log(`Image test result for ${img.filename}:`, result);
                    
                    if (!result.exists) {
                        showNotification(`Image ${img.filename} not accessible!`, 'error');
                        console.error(`Image not found: ${img.filename}`, result);
                    }
                } catch (error) {
                    console.error(`Failed to test image ${img.filename}:`, error);
                }
            }
            
            showNotification('Image accessibility test completed. Check console for details.', 'success');
        }

        function initializeSampleData() {
            const baseSampleData = {
                "name": "John Doe",
                "email": "john.doe@example.com",
                "date": "2024-01-15",
                "company": "Example Corp",
                "position": "Software Engineer",
                "gender": "Male",
                "status": "Active"
            };

            if (uploadedImages.length > 0) {
                uploadedImages.forEach((img, index) => {
                    const imageName = `image_${index + 1}`;
                    baseSampleData[imageName] = window.location.origin + img.url;
                });
            } else {
                baseSampleData.logo = "https://example.com/logo.png";
                baseSampleData.signature = "https://example.com/signature.png";
            }

            sampleData.value = JSON.stringify(baseSampleData, null, 2);
        }

        // Initialize
        setMode('text');
        refreshImageList();
        initializeSampleData();
    </script>
</body>
</html>